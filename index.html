<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>tetris</title>
</head>
<body>
  <canvas id="canvas"></canvas>
  <script>
  //落ちるスピード
    const GAME_SPEED = 800;
  //フィールドサイズ
    const FIELD_COL = 10;
    const FIELD_ROW = 20;
    // const FIELD_WALL = 1;
    // const FIELD_FLOOR = 1;
    // const FIELD_SPACE = 2;
    const BLOCK_SIZE = 20;
    // let field = [FIELD_ROW + FIELD_SPACE + FIELD_FLOOR, FIELD_COL + FIELD_WALL * 2];

    // for(let i = 0; i < field[0].length; i++){
    //   field[i, 0] = 8;
    //   field[i, field[1].length - 1] = 8;
    // }for(let i = 0; i < field[1].length; i++){
    //   field[field(0).length - 1, i] = 8;
    // }

    // canvas.width = BLOCK_SIZE * FIELD_COL;
    // canvas.height = BLOCK_SIZE * FIELD_ROW;
    // for(let i = 0; i < field[0].length; i++){
    //   for(let j = 0; j < field[1].length; j++){
    //     canvas.fillStyle = "#fff";
    //     canvas.fillRect(BLOCK_SIZE, BLOCK_SIZE, j * BLOCK_SIZE, i * BLOCK_SIZE);
    //   }
    // }

  // ブロック一つのサイズ
  // スクリーンサイズ
    const SCREEN_W = BLOCK_SIZE * FIELD_COL;
    const SCREEN_H = BLOCK_SIZE * FIELD_ROW;
  //テトロミノのサイズ
    const TETRO_SIZE = 4;

    let canvas = document.getElementById("canvas");
    let can = canvas.getContext("2d");

    canvas.width = SCREEN_W;
    canvas.height = SCREEN_H;
    canvas.style.border = "4px solid #000";

  // テトロミノ本体
  const TETRO_COLORS = [
    "#000",
    "#0FF",
    "#F60",
    "#000080",
    "#F0F",
    "#FF0",
    "#F00",
    "#008000",
  ];

  const TETRO_TYPES = [
    //0.空
    [],
    //1.I
    [
      [0, 0, 0, 0],
      [1, 1, 1, 1],
      [0, 0, 0, 0],
      [0, 0, 0, 0]
    ],
    //2.L
    [
      [1, 0, 0],
      [1, 0, 0],
      [1, 1, 0],
    ],
    //3.J
    [
      [0, 1, 0],
      [0, 1, 0],
      [1, 1, 0],
    ],
    //4.T
    [
      [1, 0, 0],
      [1, 1, 0],
      [1, 0, 0],
    ],
    //5.O
    [
      [1, 1],
      [1, 1],
    ],
    //6.Z
    [
      [1, 1, 0],
      [0, 1, 1],
      [0, 0, 0]
    ],
    //7.S
    [
      [0, 1, 1],
      [1, 1, 0],
      [0, 0, 0]
    ]
  ];

  const START_X = FIELD_COL/2 - TETRO_SIZE/2;
  const START_Y = 0;
  let tetro;

  //テトロミノの座標
    let tetro_x = START_X;
    let tetro_y = START_Y;
  //テトロミノの形
    let tetro_t;
  //フィールド中身
    let fieldd = [];
  //ゲームオーバーフラグ
  let over = false;
  //消したライン数
    let lines = 0;
  //スコア
    let score = 0;



    tetro_t = Math.floor(Math.random()*(TETRO_TYPES.length-1))+1;
    tetro = TETRO_TYPES[tetro_t];

    init();
    drawAll();

    setInterval(dropTetro, GAME_SPEED);

  //初期化
    function init(){
      for(let y=0; y<FIELD_ROW ; y++){
        fieldd[y] = [];
        for(let x=0; x<FIELD_COL ; x++){
          fieldd[y][x] = 0;
        }
      }
    }


  // ブロック一つを描画する
    function drawBlock(x, y, c){
      let px = x * BLOCK_SIZE;
      let py = y * BLOCK_SIZE;
      can.fillStyle = TETRO_COLORS[c];
      can.fillRect(px, py, BLOCK_SIZE, BLOCK_SIZE);
      can.strokeStyle = "";
      can.strokeRect(px, py, BLOCK_SIZE, BLOCK_SIZE);
    }

  //フィールドを表示する
    function drawAll(){
      can.clearRect(0, 0, SCREEN_W, SCREEN_H);
      for(let y=0; y<FIELD_ROW ; y++){
        for(let x=0; x<FIELD_COL ; x++){
          if(fieldd[y][x]){
            drawBlock(x, y, fieldd[y][x])
          }
        }
      }
      for(let y=0; y<TETRO_SIZE ; y++){
        for(let x=0; x<TETRO_SIZE ; x++){
          if(tetro[y][x]){
            drawBlock(tetro_x+x, tetro_y+y, tetro_t)
          }
        }
      }
      if(over){
        let s = "GAME OVER"
        can.font = "40px 'MS ゴシック";
        let w = can.measureText(s).width;
        let x = SCREEN_W/2 - w/2;
        let y = SCREEN_H/2 - 20;
        can.lineWidth = 4;
        can.strokeText(s, x, y);
        can.fillStyle = "white";
        can.fillText(s, x, y)
      }
    }

  // ブロックの衝突判定
    function checkMove(mx, my, ntetro){
      if(ntetro == undefined) ntetro = tetro;
      for(let y=0; y<TETRO_SIZE ; y++){
        for(let x=0; x<TETRO_SIZE ; x++){
          if(ntetro[y][x]){
            let nx = tetro_x + mx + x;
            let ny = tetro_y + my + y;
            if(ny < 0 || nx < 0 || ny >= FIELD_ROW || nx >= FIELD_COL || fieldd[ny][nx]){
              return false;
            }
          }
        }
      }
      return true;
    }

  // テトロの回転
    function rotate(){
      let ntetro = [];
      for(let y=0; y<TETRO_SIZE ; y++){
        ntetro[y] = [];
        for(let x=0; x<TETRO_SIZE ; x++){
          ntetro[y][x] = tetro[TETRO_SIZE-x-1][y];
        }
      }
      return ntetro;
    }

  // テトロを固定する
    function fixTetro(){
      for(let y=0; y<TETRO_SIZE ; y++){
        for(let x=0; x<TETRO_SIZE ; x++){
          if(tetro[y][x]){
            fieldd[tetro_y + y][tetro_x + x] = tetro_t;
          }
        }
      }
    }

  // lineが揃ったかチェックして消す
    function checkLine(){
      let linec = 0;
      for(let y=0; y<FIELD_ROW ; y++){
        let flag = true;
        for(let x=0; x<FIELD_COL ; x++){
          if(!fieldd[y][x]){
            flag = false;
            break;
          }
        }
        if(flag){
          linec++;
          for(let ny = y; ny>0 ; ny--){
            for(let nx = 0; nx<FIELD_COL ; nx++){
              fieldd[ny][nx] = fieldd[ny-1][nx];
            }
          }
        }
      }
    }

  //ブロックの落ちる処理
    function dropTetro(){
      if(over) return;
      if(checkMove(0, 1))tetro_y++;
      else{
        fixTetro();
        checkLine();
        tetro_t = Math.floor(Math.random()*(TETRO_TYPES.length-1))+1;
        tetro = TETRO_TYPES[tetro_t];
        tetro_x = START_X;
        tetro_y = START_Y;
        if(!checkMove(0, 0)){
          over = true;
        }
      }
      drawAll();
    }
  //キーボードが押された時の処理
    document.onkeydown = function(e){
      if(over) return;
      switch(e.keyCode){
        case 37: //左
          if(checkMove(-1, 0))tetro_x--;
          break;
        case 38: //上
          if(checkMove(0, -1))tetro_y--;
          break;
        case 39: //右
          if(checkMove(1, 0))tetro_x++;
          break;
        case 40: //下
          if(checkMove(0, 1))tetro_y++;
          break;
        case 32: //スペース
          let ntetro = rotate();
          if(checkMove(0, 0, ntetro))tetro = ntetro;
          break;
      }
      drawAll();
    }
  </script>
</body>
</html>